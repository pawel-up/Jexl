import type { Grammar, ASTNode, ArrayLiteralNode, BinaryExpressionNode, ConditionalExpressionNode, FilterExpressionNode, IdentifierNode, LiteralNode, ObjectLiteralNode, FunctionCallNode, UnaryExpressionNode } from '../grammar.js'

const poolNames = {
  functions: 'Jexl Function',
  transforms: 'Transform'
} as const

/**
 * The Evaluator takes a Jexl expression tree as generated by the
 * {@link Parser} and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate many different
 * expressions, and does not have to be reinstantiated for each.
 * @param grammar A grammar object against which to evaluate the expression
 *      tree
 * @param context A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier. Any
 *      Promise values will be passed to the expression as their resolved
 *      value.
 * @param relativeContext A map or array to be accessed to resolve the value of a relative identifier.
 */
export default class Evaluator {
  _grammar: Grammar
  _context: Record<string, unknown>
  _relContext: Record<string, unknown>

  constructor(grammar: Grammar, context: Record<string, unknown>, relativeContext?: Record<string, unknown>) {
    this._grammar = grammar
    this._context = context || {}
    this._relContext = relativeContext || this._context
  }

  /**
   * Evaluates an expression tree within the configured context.
   * @param ast An expression tree object
   * @returns resolves with the resulting value of the expression.
   */
  async eval(ast: ASTNode): Promise<unknown> {
    switch (ast.type) {
      case 'ArrayLiteral':
        return this._handleArrayLiteral(ast)
      case 'BinaryExpression':
        return this._handleBinaryExpression(ast)
      case 'ConditionalExpression':
        return this._handleConditionalExpression(ast)
      case 'FilterExpression':
        return this._handleFilterExpression(ast)
      case 'Identifier':
        return this._handleIdentifier(ast)
      case 'Literal':
        return this._handleLiteral(ast)
      case 'ObjectLiteral':
        return this._handleObjectLiteral(ast)
      case 'FunctionCall':
        return this._handleFunctionCall(ast)
      case 'UnaryExpression':
        return this._handleUnaryExpression(ast)
      default:
        throw new Error(`Unknown AST node type: ${(ast as any).type}`)
    }
  }

  /**
   * Simultaneously evaluates each expression within an array, and delivers the
   * response as an array with the resulting values at the same indexes as their
   * originating expressions.
   * @param arr An array of expression trees to be evaluated
   * @returns resolves with the result array
   */
  evalArray(arr: ASTNode[]): Promise<unknown[]> {
    return Promise.all(arr.map((elem) => this.eval(elem)))
  }

  /**
   * Simultaneously evaluates each expression within a map, and delivers the
   * response as a map with the same keys, but with the evaluated result for each
   * as their value.
   * @param map A map of expression names to expression trees to be evaluated
   * @returns resolves with the result map.
   */
  async evalMap(map: Record<string, ASTNode>): Promise<Record<string, unknown>> {
    const keys = Object.keys(map)
    const result: Record<string, unknown> = {}
    const asts = keys.map((key) => {
      const ast = map[key]
      if (!ast) {
        throw new Error(`No AST found for key: ${key}`)
      }
      return this.eval(ast)
    })
    const vals = await Promise.all(asts)
    vals.forEach((val, idx) => {
      const key = keys[idx]
      if (key !== undefined) {
        result[key] = val
      }
    })
    return result
  }

  /**
   * Applies a filter expression with relative identifier elements to a subject.
   * The intent is for the subject to be an array of subjects that will be
   * individually used as the relative context against the provided expression
   * tree. Only the elements whose expressions result in a truthy value will be
   * included in the resulting array.
   *
   * If the subject is not an array of values, it will be converted to a single-
   * element array before running the filter.
   * @param subject The value to be filtered usually an array. If this value is
   *      not an array, it will be converted to an array with this value as the
   *      only element.
   * @param expr The expression tree to run against each subject. If the
   *      tree evaluates to a truthy result, then the value will be included in
   *      the returned array otherwise, it will be eliminated.
   * @returns resolves with an array of values that passed the expression filter.
   * @private
   */
  async _filterRelative(subject: unknown, expr: ASTNode): Promise<unknown[]> {
    const promises: Array<Promise<unknown>> = []
    let subjectArray: unknown[]
    if (!Array.isArray(subject)) {
      subjectArray = subject === undefined ? [] : [subject]
    } else {
      subjectArray = subject
    }
    subjectArray.forEach((elem) => {
      const evalInst = new Evaluator(
        this._grammar,
        this._context,
        elem as Record<string, unknown>
      )
      promises.push(evalInst.eval(expr))
    })
    const values = await Promise.all(promises)
    const results: unknown[] = []
    values.forEach((value, idx) => {
      if (value) {
        results.push(subjectArray[idx])
      }
    })
    return results
  }

  /**
   * Applies a static filter expression to a subject value.  If the filter
   * expression evaluates to boolean true, the subject is returned if false,
   * undefined.
   *
   * For any other resulting value of the expression, this function will attempt
   * to respond with the property at that name or index of the subject.
   * @param subject The value to be filtered.  Usually an Array (for which
   *      the expression would generally resolve to a numeric index) or an
   *      Object (for which the expression would generally resolve to a string
   *      indicating a property name)
   * @param expr The expression tree to run against the subject
   * @returns resolves with the value of the drill-down.
   * @private
   */
  async _filterStatic(subject: unknown, expr: ASTNode): Promise<unknown> {
    const res = await this.eval(expr)
    if (typeof res === 'boolean') {
      return res ? subject : undefined
    }
    // Type guard for indexable types
    if (subject != null && (typeof subject === 'object' || Array.isArray(subject))) {
      return (subject as any)[res as string | number]
    }
    return undefined
  }

  // ===== Private Handler Methods =====

  /**
   * Evaluates an ArrayLiteral by returning its value, with each element
   * independently run through the evaluator.
   */
  private async _handleArrayLiteral(ast: ArrayLiteralNode): Promise<unknown[]> {
    return this.evalArray(ast.value)
  }

  /**
   * Evaluates a BinaryExpression node by running the Grammar's evaluator for
   * the given operator. Note that binary expressions support two types of
   * evaluators: `eval` is called with the left and right operands pre-evaluated.
   * `evalOnDemand`, if it exists, will be called with the left and right operands
   * each individually wrapped in an object with an "eval" function that returns
   * a promise with the resulting value. This allows the binary expression to
   * evaluate the operands conditionally.
   */
  private async _handleBinaryExpression(ast: BinaryExpressionNode): Promise<unknown> {
    const grammarOp = this._grammar.elements[ast.operator]
    
    if (!grammarOp) {
      throw new Error(`Unknown binary operator: ${ast.operator}`)
    }
    
    if ('evalOnDemand' in grammarOp && grammarOp.evalOnDemand) {
      const wrap = (subAst: ASTNode) => ({ eval: () => this.eval(subAst) })
      return grammarOp.evalOnDemand(wrap(ast.left), wrap(ast.right))
    }
    
    if ('eval' in grammarOp && grammarOp.eval) {
      const [leftVal, rightVal] = await Promise.all([
        this.eval(ast.left), 
        this.eval(ast.right)
      ])
      return grammarOp.eval(leftVal, rightVal)
    }
    
    throw new Error(`Binary operator ${ast.operator} has no eval function`)
  }

  /**
   * Evaluates a ConditionalExpression node by first evaluating its test branch,
   * and resolving with the consequent branch if the test is truthy, or the
   * alternate branch if it is not. If there is no consequent branch, the test
   * result will be used instead.
   */
  private async _handleConditionalExpression(ast: ConditionalExpressionNode): Promise<unknown> {
    const res = await this.eval(ast.test)
    if (res) {
      if (ast.consequent) {
        return this.eval(ast.consequent)
      }
      return res
    }
    return this.eval(ast.alternate)
  }

  /**
   * Evaluates a FilterExpression by applying it to the subject value.
   */
  private async _handleFilterExpression(ast: FilterExpressionNode): Promise<unknown> {
    const subject = await this.eval(ast.subject)
    if (ast.relative) {
      return this._filterRelative(subject, ast.expr)
    }
    return this._filterStatic(subject, ast.expr)
  }

  /**
   * Evaluates an Identifier by either stemming from the evaluated 'from'
   * expression tree or accessing the context provided when this Evaluator was
   * constructed.
   */
  private async _handleIdentifier(ast: IdentifierNode): Promise<unknown> {
    if (!ast.from) {
      return ast.relative ? this._relContext[ast.value] : this._context[ast.value]
    }
    
    const context = await this.eval(ast.from)
    if (context === undefined || context === null) {
      return undefined
    }
    
    let targetContext = context
    if (Array.isArray(context)) {
      targetContext = context[0]
    }
    
    return (targetContext as any)?.[ast.value]
  }

  /**
   * Evaluates a Literal by returning its value property.
   */
  private _handleLiteral(ast: LiteralNode): unknown {
    return ast.value
  }

  /**
   * Evaluates an ObjectLiteral by returning its value, with each key
   * independently run through the evaluator.
   */
  private async _handleObjectLiteral(ast: ObjectLiteralNode): Promise<Record<string, unknown>> {
    return this.evalMap(ast.value)
  }

  /**
   * Evaluates a FunctionCall node by applying the supplied arguments to a
   * function defined in one of the grammar's function pools.
   */
  private async _handleFunctionCall(ast: FunctionCallNode): Promise<unknown> {
    const poolName = poolNames[ast.pool]
    if (!poolName) {
      throw new Error(`Corrupt AST: Pool '${ast.pool}' not found`)
    }
    
    const pool = this._grammar[ast.pool]
    const func = pool[ast.name]
    if (!func) {
      throw new Error(`${poolName} ${ast.name} is not defined.`)
    }
    
    const args = await this.evalArray(ast.args || [])
    return (func as any)(...args)
  }

  /**
   * Evaluates a Unary expression by passing the right side through the
   * operator's eval function.
   */
  private async _handleUnaryExpression(ast: UnaryExpressionNode): Promise<unknown> {
    const right = await this.eval(ast.right)
    const grammarOp = this._grammar.elements[ast.operator]
    
    if (!grammarOp) {
      throw new Error(`Unknown unary operator: ${ast.operator}`)
    }
    
    if ('eval' in grammarOp && grammarOp.eval) {
      // Unary operators only take one argument
      return (grammarOp.eval as any)(right)
    }
    
    throw new Error(`Unary operator ${ast.operator} has no eval function`)
  }
}
